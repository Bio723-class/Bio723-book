[["index.html", "Biology 723: Statistical Computing for Biologists Chapter 1 Introduction 1.1 Accessing older versions of the course notes 1.2 How to use these lecture notes", " Biology 723: Statistical Computing for Biologists Paul M. Magwene 2021-01-19 Chapter 1 Introduction Bio 723 is a course I offer at Duke University. The focus of this course is statistical computing for the biological sciences with an emphasis on common multivariate statistical methods and techniques for exploratory data analysis. A major goal of the course is to help graduate students in the biological sciences develop practical insights into methods that they are likely to encounter in their own research, and the potential advantages and pitfalls that come with their use. In terms of mathematical perspectives, the course emphasize a geometric approach to understanding multivariate statistics. I try to help students develop an intuition for the geometry of vector spaces and discuss topics like correlation, regression, and principal components analysis in terms of angles between vectors, dot products, and projection. This course also provides an introduction to the R language/statistical computing environment. 1.1 Accessing older versions of the course notes The material covered in Bio 723 changes a bit from year to year. If youd like to access older versions of the course notes, I will be making these available on the Releases page of the Github site for this book. 1.2 How to use these lecture notes In this and future materials to be posted on the course website youll encounter blocks of R code. Your natural intuition will be to cut and paste commands or code blocks into the R interpretter to save yourself the typing. DO NOT DO THIS!! In each of the examples below, I provide example input, but I dont show you the output. Its your job to type in these examples at the R console, evaluate what you typed, and to look at and think critically about the output. You will make mistakes and generate errors! Part of learning any new skill is making mistakes, figuring out where you went wrong, and correcting those mistakes. In the process of fixing those errors, youll learn more about how R works, and how to avoid such errors, or correct bugs in your own code in the future. If you cut and paste the examples into the R interpretter the code will run, but you will learn less than if you input the code yourself and youll be less capable of apply the concepts in new situations. The R interpretter, like all programming languages, is very exacting. A mispelled variable or function name, a stray period, or an unbalanced parenthesis will raise an error and finding the sources of such errors can sometimes be tedious and frustrating. Persist! If you read your code critically, think about what your doing, and seek help when needed (teaching team, R help, Google, etc) youll eventually get better at debugging your code. But keep in mind that like most new skills, learning to write and debug your code efficiently takes time and experience. "],["getting-started-with-r.html", "Chapter 2 Getting Started with R 2.1 What is R? 2.2 What is RStudio? 2.3 Entering commands in the console 2.4 Comments 2.5 Using R as a Calculator 2.6 Variable assignment 2.7 Data types 2.8 Packages 2.9 The R Help System", " Chapter 2 Getting Started with R 2.1 What is R? R is a statistical computing environment and programming language. It is free, open source, and has a large and active community of developers and users. There are many different R packages (libraries) available for conducting out a wide variety of different analyses, for everything from genome sequence data to geospatial information. 2.2 What is RStudio? RStudio (http://www.rstudio.com/) is an open source integrated development environment (IDE) that provides a nicer graphical interface to R than does the default R GUI. The figure below illustrates the RStudio interface, in its default configuration. For the exercises below youll be primarily entering commands in the console window. Well review key parts of the RStudio interface in greater detail in class. Figure 2.1: RStudio window with the panes labeled 2.3 Entering commands in the console You can type commands directly in the console. When you hit Return (Enter) on your keyboard the text you typed is evaluated by the R interpreter. This means that the R program reads your commands, makes sure there are no syntax errors, and then carries out any commands that were specified. Try evaluating the following arithmetic commands in the console: 10 + 5 10 - 5 10 / 5 10 * 5 If you type an incomplete command and then hit Return on your keyboard, the console will show a continuation line marked by a + symbol. For example enter the incomplete statement (10 + 5 and then hit Enter. You should see something like this. &gt; (10 + 5 + The continuation line tells you that R is waiting for additional input before it evaluates what you typed. Either complete your command (e.g. type the closing parenthesis) and hit Return, or hit the Esc key to exit the continuation line without evaluating what you typed. 2.4 Comments When working in the R console, or writing R code, the pound symbol (#) indicates the start of a comment. Anything after the #, up to the end of the current line, is ignored by the R interpretter. # This line will be ignored 5 + 4 # the first part of this line, up to the #, will be evaluated Throughout this course I will often include short explanatory comments in my code examples. When I want to display the output generated by an R statement typed at the console I will generally use a display convention in which I prepend the results with the symbols ##. 5 + 4 # same as above but with output displayed ## [1] 9 2.5 Using R as a Calculator The simplest way to use R is as a fancy calculator. Evaluate each of the following statements in the console. 10 + 2 # addition 10 - 2 # subtraction 10 * 2 # multiplication 10 / 2 # division 10 ^ 2 # exponentiation 10 ** 2 # alternate exponentiation pi * 2.5^2 # R knows about some constants such as Pi 10 %% 3 # modulus operator -- gives remainder after division 10 %/% 3 # integer division Be aware that certain operators have precedence over others. For example multiplication and division have higher precedence than addition and subtraction. Use parentheses to disambiguate potentially confusing statements. (10 + 2)/4-5 # was the output what you expected? (10 + 2)/(4-5) # compare the answer to the above Division by zero produces an object that represents infinite numbers. Infinite values can be either positive or negative 1/0 ## [1] Inf -1/0 ## [1] -Inf Invalid calculations produce a objected called NaN which is short for Not a Number: 0/0 # invalid calculation ## [1] NaN 2.5.1 Common mathematical functions Many commonly used mathematical functions are built into R. Here are some examples: abs(-3) # absolute value ## [1] 3 cos(pi/3) # cosine ## [1] 0.5 sin(pi/3) # sine ## [1] 0.8660254 log(10) # natural logarithm ## [1] 2.302585 log10(10) # log base 10 ## [1] 1 log2(10) # log base 2 ## [1] 3.321928 exp(1) # exponential function ## [1] 2.718282 sqrt(10) # square root ## [1] 3.162278 10^0.5 # same as square root ## [1] 3.162278 2.6 Variable assignment An important programming concept in all programming languages is that of variable assignment. Variable assignment is the act of creating labels that point to particular data values in a computers memory, which allows us to apply operations to the labels rather than directly to specific. Variable assignment is an important mechanism of abstracting and generalizing computational operations. Variable assignment in R is accomplished with the assignment operator, which is designated as &lt;- (left arrow, constructed from a left angular brack and the minus sign). This is illustrated below: x &lt;- 10 # assign the variable name &#39;x&#39; the value 10 sin(x) # apply the sin function to the value x points to ## [1] -0.5440211 x &lt;- pi # x now points to a different value sin(x) # the same function call now produces a different result ## [1] 1.224606e-16 # note that sin(pi) == 0, but R returns a floating point value very # very close to but not zero 2.6.1 Valid variable names As described in the R documentation, A syntactically valid name consists of letters, numbers and the dot or underline characters and starts with a letter or the dot not followed by a number. Names such as .2way are not valid, and neither are the reserved words. Here are some examples of valid and invalid variable names. Mentally evaluate these based on the definition above, and then evaluate these in the R interpetter to confirm your understanding : x &lt;- 10 x.prime &lt;- 10 x_prime &lt;- 10 my.long.variable.name &lt;- 10 another_long_variable_name &lt;- 10 _x &lt;- 10 .x &lt;- 10 2.x &lt;- 2 * x 2.7 Data types The phrase data types refers to the representations of information that a programming language provides. In R, there are three core data types representing numbes, logical values, and strings. You can use the function typeof() to get information about an objects type in R. 2.7.1 Numeric data types There are three standard types of numbers in R. double  this is the default numeric data type, and is used to represent both real numbers and whole numbers (unless you explicitly ask for integers, see below). double is short for double precision floating point value. All of the previous computations youve seen up until this point used data of type double. typeof(10.0) # real number ## [1] &quot;double&quot; typeof(10) # whole numbers default to doubles ## [1] &quot;double&quot; integer  when your numeric data involves only whole numbers, you can get slighly better performance using the integer data type. You must explicitly ask for numbers to be treated as integers. typeof(as.integer(10)) # now treated as an integer ## [1] &quot;integer&quot; complex  R has a built-in data type to represent complex numbers  numbers with a real and imaginary component. We wont encounter the use of complex numbers in this course, but they do have many important uses in mathematics and engineering and also have some interesting applications in biology. typeof(1 + 0i) ## [1] &quot;complex&quot; sqrt(-1) # sqrt of -1, using doubles ## [1] NaN sqrt(-1 + 0i) # sqrt of -1, using complex numbers ## [1] 0+1i 2.7.2 Logical values When we compare values to each other, our calculations no longer return doubles but rather TRUE and FALSE values. This is illustrated below: 10 &lt; 9 # is 10 less than 9? ## [1] FALSE 10 &gt; 9 # is 10 greater than 9? ## [1] TRUE 10 &lt;= (5 * 2) # less than or equal to? ## [1] TRUE 10 &gt;= pi # greater than or equal to? ## [1] TRUE 10 == 10 # equals? ## [1] TRUE 10 != 10 # does not equal? ## [1] FALSE TRUE and FALSE objects are of logical data type (known as Booleans in many other languages, after the mathematician George Boole). typeof(TRUE) typeof(FALSE) x &lt;- FALSE typeof(x) # x points to a logical x &lt;- 1 typeof(x) # the variable x no longer points to a logical When working with numerical data, tests of equality can be tricky. For example, consider the following two comparisons: 10 == (sqrt(10)^2) # Surprised by the result? See below. 4 == (sqrt(4)^2) # Even more confused? Mathematically we know that both \\((\\sqrt{10})^2 = 10\\) and \\((\\sqrt{4})^2 = 4\\) are true statements. Why does R tell us the first statement is false? What were running into here are the limits of computer precision. A computer cant represent \\(\\sqrt 10\\) exactly, whereas \\(\\sqrt 4\\) can be exactly represented. Precision in numerical computing is a complex subject and a detailed discussion is beyond the scope of this course. However, its important to be aware of this limitation (this limitation is true of any programming language, not just R). To test near equality R provides a function called all.equal(). This function takes two inputs  the numerical values to be compared  and returns TRUE if their values are equal up to a certain level of tolerance (defined by the built-in numerical precision of your computer). all.equal(10, sqrt(10)^2) ## [1] TRUE Heres another example where the simple equality operator returns an unexpected result, but all.equal() produces the comparison were likely after. sin(pi) == 0 ## [1] FALSE all.equal(sin(pi), 0) ## [1] TRUE 2.7.2.1 Logical operators Logical values support Boolean operations, like logical negation (not), and, or, xor, etc. This is illustrated below: !TRUE # logical negation -- reads as &quot;not x&quot; ## [1] FALSE TRUE &amp; FALSE # AND: are x and y both TRUE? ## [1] FALSE TRUE | FALSE # OR: are either x or y TRUE? ## [1] TRUE xor(TRUE,FALSE) # XOR: is either x or y TRUE, but not both? ## [1] TRUE The function isTRUE can be useful for evaluating the state of a variable: x &lt;- sample(1:10, 1) # sample a random number in the range 1 to 10 isTRUE(x &gt; 5) # was the random number picked greater than 5? ## [1] TRUE 2.7.3 Character strings Character strings (character) represent single textual characters or a longer sequence of characters. They are created by enclosing the characters in text either single our double quotes. typeof(&quot;abc&quot;) # double quotes ## [1] &quot;character&quot; typeof(&#39;abc&#39;) # single quotes ## [1] &quot;character&quot; Character strings have a length, which can be found using the nchar function: first.name &lt;- &quot;jasmine&quot; nchar(first.name) ## [1] 7 last.name &lt;- &#39;smith&#39; nchar(last.name) ## [1] 5 There are a number of built-in functions for manipulating character strings. Here are some of the most common ones. 2.7.3.1 Joining strings The paste() function joins two characters strings together: paste(first.name, last.name) # join two strings ## [1] &quot;jasmine smith&quot; paste(&quot;abc&quot;, &quot;def&quot;) ## [1] &quot;abc def&quot; Notice that paste() adds a space between the strings? If we didnt want the space we can call the paste() function with an optional argument called sep (short for separator) which specifies the character(s) that are inserted between the joined strings. paste(&quot;abc&quot;, &quot;def&quot;, sep = &quot;&quot;) # join with no space; &quot;&quot; is an empty string ## [1] &quot;abcdef&quot; paste0(&quot;abc&quot;, &quot;def&quot;) # an equivalent function with no space in newer version of R ## [1] &quot;abcdef&quot; paste(&quot;abc&quot;, &quot;def&quot;, sep = &quot;|&quot;) # join with a vertical bar ## [1] &quot;abc|def&quot; 2.7.3.2 Splitting strings The strsplit() function allows us to split a character string into substrings according to matches to a specified split string (see ?strsplit for details). For example, we could break a sentence into its constituent words as follows: sentence &lt;- &quot;Call me Ishmael.&quot; words &lt;- strsplit(sentence, &quot; &quot;) # split on space words ## [[1]] ## [1] &quot;Call&quot; &quot;me&quot; &quot;Ishmael.&quot; Notice that strsplit() is the reverse of paste(). 2.7.3.3 Substrings The substr() function allows us to extract a substring from a character object by specifying the first and last positions (indices) to use in the extraction: substr(&quot;abcdef&quot;, 2, 5) # get substring from characters 2 to 5 ## [1] &quot;bcde&quot; substr(first.name, 1, 3) # get substring from characters 1 to ## [1] &quot;jas&quot; 2.8 Packages Packages are libraries of R functions and data that provide additional capabilities and tools beyond the standard library of functions included with R. Hundreds of people around the world have developed packages for R that provide functions and related data structures for conducting many different types of analyses. Throughout this course youll need to install a variety of packages. Here I show the basic procedure for installing new packages from the console as well as from the R Studio interface. 2.8.1 Installing packages from the console The function install.packages() provides a quick and conveniet way to install packages from the R console. 2.8.2 Install the tidyverse package To illustrate the use of install.packages(), well install a collection of packages (a meta-package) called the tidyverse. Heres how to install the tidyverse meta-package from the R console: install.packages(&quot;tidyverse&quot;, dependencies = TRUE) The first argument to install.packages gives the names of the package we want to install. The second argument, dependencies = TRUE, tells R to install any additional packages that tidyverse depends on. 2.8.3 Installing packages from the RStudio dialog You can also install packages using a graphical dialog provided by RStudio. To do so pick the Packages tab in RStudio, and then click the Install button. Figure 2.2: The Packages tab in RStudio In the packages entry box you can type the name of the package you wish to install. Lets install another useful package called stringr. Type the package name in the Packages field, make sure the Install dependencies check box is checked, and then press the Install button. Figure 2.3: Package Install Dialog 2.8.4 Loading packages with the library() function Once a package is installed on your computer, the package can be loaded into your R session using the library function. To insure our previous install commands worked correctly, lets load one of the packages we just installed. library(tidyverse) Since the tidyverse pacakge is a meta-package it provides some additional info about the sub-packages that got loaded. When you load tidyverse, you will also see a message about Conflicts as several of the functions provided in the dplyr package (a sub-package in tidyverse) conflict with names of functions provided by the stats package which usually gets automically loaded when you start R. The conflicting funcdtions are filter and lag. The conflicting functions in the stats package are lag and filter which are used in time series analysis. The dplyr functions are more generally useful. Furthermore, if you need these masked functions you can still access them by prefacing the function name with the name of the package (e.g. stats::filter). We will use the tidyverse package for almost every class session and assignment in this class. Get in the habit of including the library(tidyverse) statement in all of your R documents. 2.9 The R Help System R comes with fairly extensive documentation and a simple help system. You can access HTML versions of the R documentation under the Help tab in Rstudio. The HTML documentation also includes information on any packages youve installed. Take a few minutes to browse through the R HTML documentation. In addition to the HTML documentation there is also a search box where you can enter a term to search on (see red arrow in figure below). Figure 2.4: The RStudio Help tab 2.9.1 Getting help from the console In addition to getting help from the RStudio help tab, you can directly search for help from the console. The help system can be invoked using the help function or the ? operator. help(&quot;log&quot;) ## starting httpd help server ... done ?log If you are using RStudio, the help results will appear in the Help tab of the Files/Plots/Packages/Help/Viewer (lower right window by default). What if you dont know the name of the function you want? You can use the help.search() function. help.search(&quot;log&quot;) In this case help.search(\"log\") returns all the functions with the string log in them. For more on help.search type ?help.search. Other useful help related functions include apropos() and example(), vignette(). apropos returns a list of all objects (including variable names and function names) in the current session that match the input string. apropos(&quot;log&quot;) ## [1] &quot;as.data.frame.logical&quot; &quot;as.logical&quot; &quot;as.logical.factor&quot; ## [4] &quot;dlogis&quot; &quot;is.logical&quot; &quot;log&quot; ## [7] &quot;log10&quot; &quot;log1p&quot; &quot;log2&quot; ## [10] &quot;logb&quot; &quot;Logic&quot; &quot;logical&quot; ## [13] &quot;logLik&quot; &quot;loglin&quot; &quot;plogis&quot; ## [16] &quot;qlogis&quot; &quot;rlogis&quot; &quot;SSlogis&quot; ## [19] &quot;winDialog&quot; &quot;winDialogString&quot; example() provides examples of how a function is used. example(log) ## ## log&gt; log(exp(3)) ## [1] 3 ## ## log&gt; log10(1e7) # = 7 ## [1] 7 ## ## log&gt; x &lt;- 10^-(1+2*1:9) ## ## log&gt; cbind(x, log(1+x), log1p(x), exp(x)-1, expm1(x)) ## x ## [1,] 1e-03 9.995003e-04 9.995003e-04 1.000500e-03 1.000500e-03 ## [2,] 1e-05 9.999950e-06 9.999950e-06 1.000005e-05 1.000005e-05 ## [3,] 1e-07 1.000000e-07 1.000000e-07 1.000000e-07 1.000000e-07 ## [4,] 1e-09 1.000000e-09 1.000000e-09 1.000000e-09 1.000000e-09 ## [5,] 1e-11 1.000000e-11 1.000000e-11 1.000000e-11 1.000000e-11 ## [6,] 1e-13 9.992007e-14 1.000000e-13 9.992007e-14 1.000000e-13 ## [7,] 1e-15 1.110223e-15 1.000000e-15 1.110223e-15 1.000000e-15 ## [8,] 1e-17 0.000000e+00 1.000000e-17 0.000000e+00 1.000000e-17 ## [9,] 1e-19 0.000000e+00 1.000000e-19 0.000000e+00 1.000000e-19 The vignette() function gives longer, more detailed documentation about libraries. Not all libraries include vignettes, but for those that do its usually a good place to get started. For example, the stringr package (which we installed above) includes a vignette. To read its vignette, type the following at the console vignette(&quot;stringr&quot;) "],["r-markdown-and-r-notebooks.html", "Chapter 3 R Markdown and R Notebooks 3.1 R Notebooks 3.2 Creating an R Notebook 3.3 The default R Notebook template 3.4 Code and Non-code blocks 3.5 Running a code chunk 3.6 Running all code chunks above 3.7 Knitting R Markdown to HTML 3.8 Sharing your reproducible R Notebook", " Chapter 3 R Markdown and R Notebooks RStudio comes with a useful set of tools, collectively called R Markdown, for generating literate statistical analyses. The idea behind literate statistical computing is that we should try to carry out our analyses in a manner that is transparent, self-explanatory, and reproducible. Literate statistical computing helps to ensure your research is reproducible because: The steps of your analyses are explicitly described, both as written text and the code and function calls used. Analyses can be more easily checked for correctness and reproduced from your literate code. Your literate code can serve as a template for future analyses, saving you time and the trouble of remembering all the gory details. As well see, R Markdown will allow us to produce statistical documents that integrate prose, code, figures, and nicely formatted mathematics so that we can share and explain our analyses to others. Sometimes those others are advisors, supervisors, or collaborators; sometimes the other is you six months from now. For the purposes of this class, you will be asked to complete problem sets in the form of R Markdown documents. R Markdown documents are written in a light-weight markup language called Markdown. Markdown provides simple plain text formatting commands for specifying the structured elements of a document. Markdown was invented as a lightweight markup language for creating web pages and blogs, and has been adopted to a variety of different purposes. This chaptern provides a brief introduction to the capabilities of R Markdown. For more complete details, including lots of examples, see the R Markdown Website. 3.1 R Notebooks Were going to create a type of R Markdown document called an R Notebook. The R Notebook Documentation describes R Notebooks as so: An R Notebook is an R Markdown document with code chunks that can be executed independently and interactively, with output visible immediately beneath the input. 3.2 Creating an R Notebook To create an R Notebook select File &gt; New File &gt; R Notebook from the files menu in RStudio. Figure 3.1: Using the File menu to create a new R Notebook. 3.3 The default R Notebook template The standard template that RStudio creates for you includes a header section like the following where you can specify document properties such as the title, author, and change the look and feel of the generated HTML document. --- title: &quot;R Notebook&quot; output: html_notebook --- The header is followed by several example sections that illustrate a few of the capabilities of R Markdown. Delete these and replace them with your own code as necessary. 3.4 Code and Non-code blocks R Markdown documents are divided into code blocks (also called chunks) and non-code blocks. Code blocks are sets of R commands that will be evalauted when the R Markdown document is run or knitted (see below). Non-code blocks include explanatory text, embedded images, etc. The default notebook template includes both code and non-code blocks. 3.4.1 Non-code blocks The first bit of text in the default notebook template is a non-code block that tells you how to use the notebook: This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. The text of non-code blocks can include lightweight markup information that can be used to format HTML or PDF output generated from the R Markdown document. Here are some examples: # Simple textual formatting This is a paragraph with plain text. Nothing fancy will happen here. This is a second paragraph with *italic*, **bold**, and `verbatim` text. # Lists ## Bullet points lists This is a list with bullet points: * Item a * Item b * Item c ## Numbered lists This is a numbered list: 1. Item 1 #. Item 2 #. Item 3 ## Mathematics R Markdown supports mathematical equations, formatted according to LaTeX conventions. Dollar signs ($) are used to offset mathematics like so: $x^2 + y^2 = z^2$. Notice from the example above that R Markdown supports LaTeX style formatting of mathematical equations. For example, $x^2 + y^2 = z^2$ appears as \\(x^2 + y^2 = z^2\\). 3.4.2 Code blocks Code blocks are delimited by matching sets of three backward ticks (```). Everything within a code block is interpretted as an R command and is evaluated by the R interpretter. Heres the first code block in the default notebook template: ``` {r} plot(cars) ``` 3.5 Running a code chunk You can run a single code block by clicking the small green Run button in the upper right hand corner of the code block as shown in the image below. Figure 3.2: Click the Run button to execute a code chunk. If you click this button the commands within this code block are executed, and any generated output is shown below the code block. Try running the first code block in the default template now. After the code chunk is executed you should see a plot embedded in your R Notebook as shown below: Figure 3.3: An R Notebook showing an embedded plot after executing a code chunk. 3.6 Running all code chunks above Next to the Run button in each code chunk is a button for Run all chunks above (see figure below). This is useful when the code chunk youre working on depends on calculations in earlier code chunks, and you want to evaluated those earlier code chunks prior to running the focal code chunk. Figure 3.4: Use the Run all chunks above button to evaluate all previous code chunks. 3.7 Knitting R Markdown to HTML Save your R Notebook as first_rnotebook.Rmd (RStudio will automatically add the .Rmd extension so you dont need to type it). You can generate an HTML version of your notebook by clicking the Preview menu on the Notebook taskbar and then choosing Knit to HTML (see image below). Figure 3.5: Use the Knit to HTML menu to generate HTML output from your R Notebook When an RMarkdown document is knit, all of the code and non-code blocks are executed in a clean environment, in order from top to bottom. An output file is generated (HTML or one of the other available output types) that shows the results of executing the notebook. By default RStudio will pop-up a window showing you the HTML output you generated. Knitting a document is a good way to make sure your analysis is reproducible. If your code compiles correctly when the document is knit, and produces the expected output, theres a good chance that someone else will be able to reproduce your analyses independently starting with your R Notebook document (after accounting for differences in file locations). 3.8 Sharing your reproducible R Notebook To share your R Notebook with someone else you just need to send them the source R Markdown file (i.e. the file with the .Rmd extension). Assuming they have access to the same source data, another user should be able to open the notebook file in RStudio and regenerate your analyses by evaluating the individual code chunks or knitting the document. In this course you will be submitting homework assignments in the form of R Notebook markdown files. "]]
